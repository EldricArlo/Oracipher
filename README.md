# Oracipher
A codebook designed for personal use only.

# fix
正常情况下的动画原理是AnimatedBookButton的展开动画是由一个叫做enterEvent的事件触发的，这个事件会在鼠标指针从按钮的外部区域移动到内部区域的时候，由操作系统发送给按钮；同样，收缩动画师由leaveEvent触发的，他在鼠标指针从按钮内部移动到外部的时候触发。

## Q
步骤A: 您的鼠标指针在“最小化”按钮上，按钮正确地展开了（enterEvent 被触发）。
步骤B: 您点击了窗口标题栏上的系统最小化按钮，此时鼠标指针没有移动。
步骤C: 窗口被最小化。从操作系统的角度看，您的鼠标指针现在位于桌面或其他窗口之上，不再位于我们的按钮之上了。因此，系统会给我们的按钮发送一个 leaveEvent。按钮收到这个信号后，正确地执行了收缩动画。到此为止，一切行为都是符合逻辑的。
步骤D: 您从任务栏点击图标，恢复了窗口。
问题的核心: 窗口恢复后，您的鼠标指针瞬间就出现在了“最小化”按钮的上方，它并没有一个“从外部移动到内部”的过程。因为它从未“离开”屏幕坐标，只是窗口在它下面消失又出现了。
最终结果: 由于没有“进入”这个动作，操作系统不会发送一个新的 enterEvent。按钮因此永远不会收到再次展开的指令，就“卡”在了收缩的状态。

## A
这个方案的核心思想是：“我不再傻等那个可能永远不会来的 enterEvent 了。我要自己设置一个闹钟，只要我的应用程序是打开的，我就每隔一小段时间（比如100毫秒）就主动去看一下鼠标到底在哪里，然后强制让按钮的样子和鼠标的实际位置保持一致。”
具体实现分为两部分：
按钮的职责简化 (AnimatedBookmarkButton)
我们给按钮增加了一个新的、简单的公共方法，叫做 check_hover_state_and_correct()。
这个方法的作用就像一个开关，它只负责回答一个问题：“根据当前鼠标在屏幕上的全局坐标，它在不在我的区域内？”
如果答案是“在，但我是收缩的”，它就强制执行展开动画。
如果答案是“不在，但我是展开的”，它就强制执行收缩动画。
它不再包含任何复杂的事件监听或自己的定时器。它只是一个被动的执行者。
侧边栏的“总指挥”角色 (SidebarView)
我们在 SidebarView（所有按钮的父容器）里创建了一个唯一的、全局的定时器 (hover_check_timer)。
这个定时器的启动和停止，只和整个应用程序窗口的状态有关：
当用户切换到我们的程序，窗口被激活时 (WindowActivate)，定时器启动。
当用户切换到其他程序，窗口失活时 (WindowDeactivate)，定时器停止（这样做是为了节省CPU，非常高效）。
当这个定时器运行时，它每隔100毫秒就会做一件简单的事：遍历侧边栏上的所有动画按钮，并挨个调用它们的 check_hover_state_and_correct() 方法。
这个方案为什么是可靠的？
因为它彻底摆脱了对不确定的 enterEvent 的依赖。无论窗口是因为最小化恢复，还是因为其他任何原因导致UI状态不同步，只要我们的应用处于前台，这个“总指挥”定时器就会孜孜不倦地进行检查和纠正，确保所有按钮的视觉状态在最多100毫秒内与鼠标的实际位置恢复同步。
